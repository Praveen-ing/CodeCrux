{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\HP\\\\OneDrive\\\\Pictures\\\\Documents\\\\Desktop\\\\CodeCrux\\\\frontend\\\\src\\\\context\\\\AuthContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// frontend/src/context/AuthContext.jsx\nimport React, { createContext, useState, useEffect, useContext } from 'react';\n// Ensure this path is correct and getUserProfile, loginUser, registerUser are exported\nimport { getUserProfile as fetchUserProfileAPI, loginUser as loginAPI, registerUser as registerAPI } from '../api/apiService.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext(null);\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [userInfo, setUserInfo] = useState(null);\n  const [loading, setLoading] = useState(true); // Start true to handle initial check\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const attemptAutoLogin = async () => {\n      console.log(\"[AuthContext] Attempting auto-login...\");\n      const storedUserInfo = localStorage.getItem('userInfo'); // Correctly declared\n      if (storedUserInfo) {\n        let parsedInfo;\n        try {\n          parsedInfo = JSON.parse(storedUserInfo);\n          // Temporarily set user info to allow API call with token (interceptor reads from localStorage)\n          // setUserInfo(parsedInfo); // This immediate setUserInfo can be removed if interceptor solely relies on localStorage\n          // and freshUserInfo is set after API call. However, it's not strictly harmful.\n\n          console.log(\"[AuthContext] attemptAutoLogin: Calling fetchUserProfileAPI...\");\n          const response = await fetchUserProfileAPI(); // This now calls /auth/me\n\n          // Preserve token from initial storage if backend profile doesn't send it\n          const freshUserInfo = {\n            ...response.data,\n            token: parsedInfo.token || response.data.token\n          };\n          console.log(\"[AuthContext] attemptAutoLogin: Fetched fresh user info:\", freshUserInfo);\n          setUserInfo(freshUserInfo);\n          localStorage.setItem('userInfo', JSON.stringify(freshUserInfo));\n        } catch (err) {\n          console.error(\"[AuthContext] attemptAutoLogin: Session validation or parsing failed.\", err.message || err);\n          localStorage.removeItem('userInfo');\n          setUserInfo(null); // Clear user info on failure\n          setError(\"Session expired or invalid. Please log in again.\"); // Set a user-friendly error\n        }\n      } else {\n        console.log(\"[AuthContext] attemptAutoLogin: No stored user info found in localStorage.\");\n      }\n      setLoading(false);\n    };\n    attemptAutoLogin();\n  }, []); // Empty dependency array ensures this runs once on mount\n\n  const refreshUserProfile = async () => {\n    console.log(\"[AuthContext] Attempting to refresh user profile...\");\n    const storedUserInfoFromStorage = localStorage.getItem('userInfo'); // Renamed to avoid confusion with state `userInfo`\n    let currentToken = null;\n    if (storedUserInfoFromStorage) {\n      try {\n        currentToken = JSON.parse(storedUserInfoFromStorage).token;\n      } catch (e) {\n        console.error(\"[AuthContext] refreshUserProfile: Error parsing stored token from localStorage\", e);\n      }\n    }\n\n    // Fallback to token from current state if not in localStorage (e.g., if localStorage was cleared but state not yet updated)\n    if (!currentToken && userInfo && userInfo.token) {\n      console.log(\"[AuthContext] refreshUserProfile: Using token from current userInfo state as fallback.\");\n      currentToken = userInfo.token;\n    }\n    if (!currentToken) {\n      console.warn(\"[AuthContext] refreshUserProfile: No token available (checked localStorage and current state).\");\n      // setError(\"Unable to refresh profile: Not authenticated.\"); // Optionally set an error\n      return; // Cannot refresh without a token\n    }\n    try {\n      // setLoading(true); // Optional: manage loading state during refresh\n      console.log(\"[AuthContext] refreshUserProfile: Calling fetchUserProfileAPI (backend /auth/me)...\");\n      const response = await fetchUserProfileAPI();\n      console.log(\"[AuthContext] refreshUserProfile: Data received from fetchUserProfileAPI (/auth/me):\", response.data);\n\n      // Ensure token is preserved. Prioritize new token from response, then existing context token, then currentToken from storage.\n      const freshUserInfo = {\n        ...response.data,\n        token: response.data.token || currentToken // Use currentToken as it's the one validated for this call\n      };\n      console.log(\"[AuthContext] refreshUserProfile: Preparing to set new userInfo:\", freshUserInfo);\n      setUserInfo(freshUserInfo);\n      localStorage.setItem('userInfo', JSON.stringify(freshUserInfo));\n      console.log(\"[AuthContext] refreshUserProfile: User profile refreshed. New streak should be:\", freshUserInfo.currentStreak);\n      setError(null); // Clear previous auth errors on successful refresh\n    } catch (err) {\n      var _err$response, _err$response$data, _err$response2, _err$response2$data, _err$response3, _err$response4;\n      console.error(\"[AuthContext] refreshUserProfile: Failed.\", ((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.message) || err.message, err);\n      setError(((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.message) || \"Failed to refresh profile. Please try logging in again.\");\n      // Potentially logout user if refresh fails due to critical auth issues (e.g., token definitively invalid)\n      if (((_err$response3 = err.response) === null || _err$response3 === void 0 ? void 0 : _err$response3.status) === 401 || ((_err$response4 = err.response) === null || _err$response4 === void 0 ? void 0 : _err$response4.status) === 403) {\n        console.log(\"[AuthContext] refreshUserProfile: Auth error during refresh, logging out.\");\n        logout(); // Call logout if token is rejected\n      }\n    } finally {\n      // setLoading(false); // Reset loading state if you used it\n    }\n  };\n  const login = async credentials => {\n    console.log(\"[AuthContext] Attempting login...\");\n    try {\n      setError(null);\n      const {\n        data\n      } = await loginAPI(credentials);\n      console.log(\"[AuthContext] Login successful, user data received:\", data);\n      setUserInfo(data);\n      localStorage.setItem('userInfo', JSON.stringify(data));\n      return data;\n    } catch (err) {\n      var _err$response5, _err$response5$data;\n      const errorMessage = ((_err$response5 = err.response) === null || _err$response5 === void 0 ? void 0 : (_err$response5$data = _err$response5.data) === null || _err$response5$data === void 0 ? void 0 : _err$response5$data.message) || err.message || 'Login failed';\n      console.error(\"[AuthContext] Login error:\", errorMessage, err);\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  };\n  const register = async userData => {\n    console.log(\"[AuthContext] Attempting registration...\");\n    try {\n      setError(null);\n      const {\n        data\n      } = await registerAPI(userData);\n      console.log(\"[AuthContext] Registration successful, user data received:\", data);\n      // Assuming backend returns user object + token upon successful registration and auto-logins:\n      setUserInfo(data);\n      localStorage.setItem('userInfo', JSON.stringify(data));\n      return data;\n    } catch (err) {\n      var _err$response6, _err$response6$data;\n      const errorMessage = ((_err$response6 = err.response) === null || _err$response6 === void 0 ? void 0 : (_err$response6$data = _err$response6.data) === null || _err$response6$data === void 0 ? void 0 : _err$response6$data.message) || err.message || 'Registration failed';\n      console.error(\"[AuthContext] Registration error:\", errorMessage, err);\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  };\n  const logout = () => {\n    console.log(\"[AuthContext] User logging out.\");\n    setUserInfo(null);\n    localStorage.removeItem('userInfo');\n    setError(null); // Clear any errors on logout\n    // Navigation should be handled by components observing userInfo\n  };\n\n  // Function to manually set error from other parts of the app if needed\n  const setGlobalAuthError = errorMessage => {\n    setError(errorMessage);\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: {\n      userInfo,\n      loading,\n      error,\n      login,\n      register,\n      logout,\n      setError: setGlobalAuthError,\n      refreshUserProfile\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 155,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"iIZjHdo4dQKyK+HkpX1jOwNhFhw=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","getUserProfile","fetchUserProfileAPI","loginUser","loginAPI","registerUser","registerAPI","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","userInfo","setUserInfo","loading","setLoading","error","setError","attemptAutoLogin","console","log","storedUserInfo","localStorage","getItem","parsedInfo","JSON","parse","response","freshUserInfo","data","token","setItem","stringify","err","message","removeItem","refreshUserProfile","storedUserInfoFromStorage","currentToken","e","warn","currentStreak","_err$response","_err$response$data","_err$response2","_err$response2$data","_err$response3","_err$response4","status","logout","login","credentials","_err$response5","_err$response5$data","errorMessage","Error","register","userData","_err$response6","_err$response6$data","setGlobalAuthError","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/HP/OneDrive/Pictures/Documents/Desktop/CodeCrux/frontend/src/context/AuthContext.jsx"],"sourcesContent":["// frontend/src/context/AuthContext.jsx\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\n// Ensure this path is correct and getUserProfile, loginUser, registerUser are exported\r\nimport { getUserProfile as fetchUserProfileAPI, loginUser as loginAPI, registerUser as registerAPI } from '../api/apiService.js';\r\n\r\nconst AuthContext = createContext(null);\r\n\r\nexport const useAuth = () => useContext(AuthContext);\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n  const [userInfo, setUserInfo] = useState(null);\r\n  const [loading, setLoading] = useState(true); // Start true to handle initial check\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    const attemptAutoLogin = async () => {\r\n      console.log(\"[AuthContext] Attempting auto-login...\");\r\n      const storedUserInfo = localStorage.getItem('userInfo'); // Correctly declared\r\n      if (storedUserInfo) {\r\n        let parsedInfo;\r\n        try {\r\n          parsedInfo = JSON.parse(storedUserInfo);\r\n          // Temporarily set user info to allow API call with token (interceptor reads from localStorage)\r\n          // setUserInfo(parsedInfo); // This immediate setUserInfo can be removed if interceptor solely relies on localStorage\r\n                                   // and freshUserInfo is set after API call. However, it's not strictly harmful.\r\n\r\n          console.log(\"[AuthContext] attemptAutoLogin: Calling fetchUserProfileAPI...\");\r\n          const response = await fetchUserProfileAPI(); // This now calls /auth/me\r\n          \r\n          // Preserve token from initial storage if backend profile doesn't send it\r\n          const freshUserInfo = { ...response.data, token: parsedInfo.token || response.data.token }; \r\n          \r\n          console.log(\"[AuthContext] attemptAutoLogin: Fetched fresh user info:\", freshUserInfo);\r\n          setUserInfo(freshUserInfo);\r\n          localStorage.setItem('userInfo', JSON.stringify(freshUserInfo));\r\n        } catch (err) {\r\n          console.error(\"[AuthContext] attemptAutoLogin: Session validation or parsing failed.\", err.message || err);\r\n          localStorage.removeItem('userInfo');\r\n          setUserInfo(null); // Clear user info on failure\r\n          setError(\"Session expired or invalid. Please log in again.\"); // Set a user-friendly error\r\n        }\r\n      } else {\r\n        console.log(\"[AuthContext] attemptAutoLogin: No stored user info found in localStorage.\");\r\n      }\r\n      setLoading(false);\r\n    };\r\n\r\n    attemptAutoLogin();\r\n  }, []); // Empty dependency array ensures this runs once on mount\r\n\r\n  const refreshUserProfile = async () => {\r\n    console.log(\"[AuthContext] Attempting to refresh user profile...\");\r\n    const storedUserInfoFromStorage = localStorage.getItem('userInfo'); // Renamed to avoid confusion with state `userInfo`\r\n    let currentToken = null;\r\n\r\n    if (storedUserInfoFromStorage) {\r\n      try {\r\n        currentToken = JSON.parse(storedUserInfoFromStorage).token;\r\n      } catch (e) {\r\n        console.error(\"[AuthContext] refreshUserProfile: Error parsing stored token from localStorage\", e);\r\n      }\r\n    }\r\n\r\n    // Fallback to token from current state if not in localStorage (e.g., if localStorage was cleared but state not yet updated)\r\n    if (!currentToken && userInfo && userInfo.token) {\r\n        console.log(\"[AuthContext] refreshUserProfile: Using token from current userInfo state as fallback.\");\r\n        currentToken = userInfo.token;\r\n    }\r\n\r\n    if (!currentToken) {\r\n      console.warn(\"[AuthContext] refreshUserProfile: No token available (checked localStorage and current state).\");\r\n      // setError(\"Unable to refresh profile: Not authenticated.\"); // Optionally set an error\r\n      return; // Cannot refresh without a token\r\n    }\r\n\r\n    try {\r\n      // setLoading(true); // Optional: manage loading state during refresh\r\n      console.log(\"[AuthContext] refreshUserProfile: Calling fetchUserProfileAPI (backend /auth/me)...\");\r\n      const response = await fetchUserProfileAPI(); \r\n      console.log(\"[AuthContext] refreshUserProfile: Data received from fetchUserProfileAPI (/auth/me):\", response.data);\r\n\r\n      // Ensure token is preserved. Prioritize new token from response, then existing context token, then currentToken from storage.\r\n      const freshUserInfo = {\r\n        ...response.data,\r\n        token: response.data.token || currentToken // Use currentToken as it's the one validated for this call\r\n      };\r\n      console.log(\"[AuthContext] refreshUserProfile: Preparing to set new userInfo:\", freshUserInfo);\r\n\r\n      setUserInfo(freshUserInfo);\r\n      localStorage.setItem('userInfo', JSON.stringify(freshUserInfo));\r\n      console.log(\"[AuthContext] refreshUserProfile: User profile refreshed. New streak should be:\", freshUserInfo.currentStreak);\r\n      setError(null); // Clear previous auth errors on successful refresh\r\n    } catch (err) {\r\n      console.error(\"[AuthContext] refreshUserProfile: Failed.\", err.response?.data?.message || err.message, err);\r\n      setError(err.response?.data?.message || \"Failed to refresh profile. Please try logging in again.\");\r\n      // Potentially logout user if refresh fails due to critical auth issues (e.g., token definitively invalid)\r\n      if (err.response?.status === 401 || err.response?.status === 403) {\r\n        console.log(\"[AuthContext] refreshUserProfile: Auth error during refresh, logging out.\");\r\n        logout(); // Call logout if token is rejected\r\n      }\r\n    } finally {\r\n      // setLoading(false); // Reset loading state if you used it\r\n    }\r\n  };\r\n\r\n  const login = async (credentials) => {\r\n    console.log(\"[AuthContext] Attempting login...\");\r\n    try {\r\n      setError(null);\r\n      const { data } = await loginAPI(credentials);\r\n      console.log(\"[AuthContext] Login successful, user data received:\", data);\r\n      setUserInfo(data); \r\n      localStorage.setItem('userInfo', JSON.stringify(data));\r\n      return data;\r\n    } catch (err) {\r\n      const errorMessage = err.response?.data?.message || err.message || 'Login failed';\r\n      console.error(\"[AuthContext] Login error:\", errorMessage, err);\r\n      setError(errorMessage);\r\n      throw new Error(errorMessage);\r\n    }\r\n  };\r\n\r\n  const register = async (userData) => {\r\n    console.log(\"[AuthContext] Attempting registration...\");\r\n    try {\r\n      setError(null);\r\n      const { data } = await registerAPI(userData);\r\n      console.log(\"[AuthContext] Registration successful, user data received:\", data);\r\n      // Assuming backend returns user object + token upon successful registration and auto-logins:\r\n      setUserInfo(data);\r\n      localStorage.setItem('userInfo', JSON.stringify(data));\r\n      return data;\r\n    } catch (err) {\r\n      const errorMessage = err.response?.data?.message || err.message || 'Registration failed';\r\n      console.error(\"[AuthContext] Registration error:\", errorMessage, err);\r\n      setError(errorMessage);\r\n      throw new Error(errorMessage);\r\n    }\r\n  };\r\n\r\n  const logout = () => {\r\n    console.log(\"[AuthContext] User logging out.\");\r\n    setUserInfo(null);\r\n    localStorage.removeItem('userInfo');\r\n    setError(null); // Clear any errors on logout\r\n    // Navigation should be handled by components observing userInfo\r\n  };\r\n  \r\n  // Function to manually set error from other parts of the app if needed\r\n  const setGlobalAuthError = (errorMessage) => {\r\n    setError(errorMessage);\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={{ \r\n        userInfo, \r\n        loading, \r\n        error, \r\n        login, \r\n        register, \r\n        logout, \r\n        setError: setGlobalAuthError, \r\n        refreshUserProfile \r\n    }}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}