{"ast":null,"code":"// frontend/src/context/AuthContext.jsx\nimport React,{createContext,useState,useEffect,useContext}from'react';// Ensure this path is correct and getUserProfile, loginUser, registerUser are exported\nimport{getUserProfile as fetchUserProfileAPI,loginUser as loginAPI,registerUser as registerAPI}from'../api/apiService.js';import{jsx as _jsx}from\"react/jsx-runtime\";const AuthContext=/*#__PURE__*/createContext(null);export const useAuth=()=>useContext(AuthContext);export const AuthProvider=_ref=>{let{children}=_ref;const[userInfo,setUserInfo]=useState(null);const[loading,setLoading]=useState(true);// Start true to handle initial check\nconst[error,setError]=useState(null);useEffect(()=>{const attemptAutoLogin=async()=>{console.log(\"[AuthContext] Attempting auto-login...\");const storedUserInfo=localStorage.getItem('userInfo');// Correctly declared\nif(storedUserInfo){let parsedInfo;try{parsedInfo=JSON.parse(storedUserInfo);// Temporarily set user info to allow API call with token (interceptor reads from localStorage)\n// setUserInfo(parsedInfo); // This immediate setUserInfo can be removed if interceptor solely relies on localStorage\n// and freshUserInfo is set after API call. However, it's not strictly harmful.\nconsole.log(\"[AuthContext] attemptAutoLogin: Calling fetchUserProfileAPI...\");const response=await fetchUserProfileAPI();// This now calls /auth/me\n// Preserve token from initial storage if backend profile doesn't send it\nconst freshUserInfo={...response.data,token:parsedInfo.token||response.data.token};console.log(\"[AuthContext] attemptAutoLogin: Fetched fresh user info:\",freshUserInfo);setUserInfo(freshUserInfo);localStorage.setItem('userInfo',JSON.stringify(freshUserInfo));}catch(err){console.error(\"[AuthContext] attemptAutoLogin: Session validation or parsing failed.\",err.message||err);localStorage.removeItem('userInfo');setUserInfo(null);// Clear user info on failure\nsetError(\"Session expired or invalid. Please log in again.\");// Set a user-friendly error\n}}else{console.log(\"[AuthContext] attemptAutoLogin: No stored user info found in localStorage.\");}setLoading(false);};attemptAutoLogin();},[]);// Empty dependency array ensures this runs once on mount\nconst refreshUserProfile=async()=>{console.log(\"[AuthContext] Attempting to refresh user profile...\");const storedUserInfoFromStorage=localStorage.getItem('userInfo');// Renamed to avoid confusion with state `userInfo`\nlet currentToken=null;if(storedUserInfoFromStorage){try{currentToken=JSON.parse(storedUserInfoFromStorage).token;}catch(e){console.error(\"[AuthContext] refreshUserProfile: Error parsing stored token from localStorage\",e);}}// Fallback to token from current state if not in localStorage (e.g., if localStorage was cleared but state not yet updated)\nif(!currentToken&&userInfo&&userInfo.token){console.log(\"[AuthContext] refreshUserProfile: Using token from current userInfo state as fallback.\");currentToken=userInfo.token;}if(!currentToken){console.warn(\"[AuthContext] refreshUserProfile: No token available (checked localStorage and current state).\");// setError(\"Unable to refresh profile: Not authenticated.\"); // Optionally set an error\nreturn;// Cannot refresh without a token\n}try{// setLoading(true); // Optional: manage loading state during refresh\nconsole.log(\"[AuthContext] refreshUserProfile: Calling fetchUserProfileAPI (backend /auth/me)...\");const response=await fetchUserProfileAPI();console.log(\"[AuthContext] refreshUserProfile: Data received from fetchUserProfileAPI (/auth/me):\",response.data);// Ensure token is preserved. Prioritize new token from response, then existing context token, then currentToken from storage.\nconst freshUserInfo={...response.data,token:response.data.token||currentToken// Use currentToken as it's the one validated for this call\n};console.log(\"[AuthContext] refreshUserProfile: Preparing to set new userInfo:\",freshUserInfo);setUserInfo(freshUserInfo);localStorage.setItem('userInfo',JSON.stringify(freshUserInfo));console.log(\"[AuthContext] refreshUserProfile: User profile refreshed. New streak should be:\",freshUserInfo.currentStreak);setError(null);// Clear previous auth errors on successful refresh\n}catch(err){var _err$response,_err$response$data,_err$response2,_err$response2$data,_err$response3,_err$response4;console.error(\"[AuthContext] refreshUserProfile: Failed.\",((_err$response=err.response)===null||_err$response===void 0?void 0:(_err$response$data=_err$response.data)===null||_err$response$data===void 0?void 0:_err$response$data.message)||err.message,err);setError(((_err$response2=err.response)===null||_err$response2===void 0?void 0:(_err$response2$data=_err$response2.data)===null||_err$response2$data===void 0?void 0:_err$response2$data.message)||\"Failed to refresh profile. Please try logging in again.\");// Potentially logout user if refresh fails due to critical auth issues (e.g., token definitively invalid)\nif(((_err$response3=err.response)===null||_err$response3===void 0?void 0:_err$response3.status)===401||((_err$response4=err.response)===null||_err$response4===void 0?void 0:_err$response4.status)===403){console.log(\"[AuthContext] refreshUserProfile: Auth error during refresh, logging out.\");logout();// Call logout if token is rejected\n}}finally{// setLoading(false); // Reset loading state if you used it\n}};const login=async credentials=>{console.log(\"[AuthContext] Attempting login...\");try{setError(null);const{data}=await loginAPI(credentials);console.log(\"[AuthContext] Login successful, user data received:\",data);setUserInfo(data);localStorage.setItem('userInfo',JSON.stringify(data));return data;}catch(err){var _err$response5,_err$response5$data;const errorMessage=((_err$response5=err.response)===null||_err$response5===void 0?void 0:(_err$response5$data=_err$response5.data)===null||_err$response5$data===void 0?void 0:_err$response5$data.message)||err.message||'Login failed';console.error(\"[AuthContext] Login error:\",errorMessage,err);setError(errorMessage);throw new Error(errorMessage);}};const register=async userData=>{console.log(\"[AuthContext] Attempting registration...\");try{setError(null);const{data}=await registerAPI(userData);console.log(\"[AuthContext] Registration successful, user data received:\",data);// Assuming backend returns user object + token upon successful registration and auto-logins:\nsetUserInfo(data);localStorage.setItem('userInfo',JSON.stringify(data));return data;}catch(err){var _err$response6,_err$response6$data;const errorMessage=((_err$response6=err.response)===null||_err$response6===void 0?void 0:(_err$response6$data=_err$response6.data)===null||_err$response6$data===void 0?void 0:_err$response6$data.message)||err.message||'Registration failed';console.error(\"[AuthContext] Registration error:\",errorMessage,err);setError(errorMessage);throw new Error(errorMessage);}};const logout=()=>{console.log(\"[AuthContext] User logging out.\");setUserInfo(null);localStorage.removeItem('userInfo');setError(null);// Clear any errors on logout\n// Navigation should be handled by components observing userInfo\n};// Function to manually set error from other parts of the app if needed\nconst setGlobalAuthError=errorMessage=>{setError(errorMessage);};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:{userInfo,loading,error,login,register,logout,setError:setGlobalAuthError,refreshUserProfile},children:children});};","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","getUserProfile","fetchUserProfileAPI","loginUser","loginAPI","registerUser","registerAPI","jsx","_jsx","AuthContext","useAuth","AuthProvider","_ref","children","userInfo","setUserInfo","loading","setLoading","error","setError","attemptAutoLogin","console","log","storedUserInfo","localStorage","getItem","parsedInfo","JSON","parse","response","freshUserInfo","data","token","setItem","stringify","err","message","removeItem","refreshUserProfile","storedUserInfoFromStorage","currentToken","e","warn","currentStreak","_err$response","_err$response$data","_err$response2","_err$response2$data","_err$response3","_err$response4","status","logout","login","credentials","_err$response5","_err$response5$data","errorMessage","Error","register","userData","_err$response6","_err$response6$data","setGlobalAuthError","Provider","value"],"sources":["C:/Users/HP/OneDrive/Pictures/Documents/Desktop/CodeCrux/frontend/src/context/AuthContext.jsx"],"sourcesContent":["// frontend/src/context/AuthContext.jsx\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\n// Ensure this path is correct and getUserProfile, loginUser, registerUser are exported\r\nimport { getUserProfile as fetchUserProfileAPI, loginUser as loginAPI, registerUser as registerAPI } from '../api/apiService.js';\r\n\r\nconst AuthContext = createContext(null);\r\n\r\nexport const useAuth = () => useContext(AuthContext);\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n  const [userInfo, setUserInfo] = useState(null);\r\n  const [loading, setLoading] = useState(true); // Start true to handle initial check\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    const attemptAutoLogin = async () => {\r\n      console.log(\"[AuthContext] Attempting auto-login...\");\r\n      const storedUserInfo = localStorage.getItem('userInfo'); // Correctly declared\r\n      if (storedUserInfo) {\r\n        let parsedInfo;\r\n        try {\r\n          parsedInfo = JSON.parse(storedUserInfo);\r\n          // Temporarily set user info to allow API call with token (interceptor reads from localStorage)\r\n          // setUserInfo(parsedInfo); // This immediate setUserInfo can be removed if interceptor solely relies on localStorage\r\n                                   // and freshUserInfo is set after API call. However, it's not strictly harmful.\r\n\r\n          console.log(\"[AuthContext] attemptAutoLogin: Calling fetchUserProfileAPI...\");\r\n          const response = await fetchUserProfileAPI(); // This now calls /auth/me\r\n          \r\n          // Preserve token from initial storage if backend profile doesn't send it\r\n          const freshUserInfo = { ...response.data, token: parsedInfo.token || response.data.token }; \r\n          \r\n          console.log(\"[AuthContext] attemptAutoLogin: Fetched fresh user info:\", freshUserInfo);\r\n          setUserInfo(freshUserInfo);\r\n          localStorage.setItem('userInfo', JSON.stringify(freshUserInfo));\r\n        } catch (err) {\r\n          console.error(\"[AuthContext] attemptAutoLogin: Session validation or parsing failed.\", err.message || err);\r\n          localStorage.removeItem('userInfo');\r\n          setUserInfo(null); // Clear user info on failure\r\n          setError(\"Session expired or invalid. Please log in again.\"); // Set a user-friendly error\r\n        }\r\n      } else {\r\n        console.log(\"[AuthContext] attemptAutoLogin: No stored user info found in localStorage.\");\r\n      }\r\n      setLoading(false);\r\n    };\r\n\r\n    attemptAutoLogin();\r\n  }, []); // Empty dependency array ensures this runs once on mount\r\n\r\n  const refreshUserProfile = async () => {\r\n    console.log(\"[AuthContext] Attempting to refresh user profile...\");\r\n    const storedUserInfoFromStorage = localStorage.getItem('userInfo'); // Renamed to avoid confusion with state `userInfo`\r\n    let currentToken = null;\r\n\r\n    if (storedUserInfoFromStorage) {\r\n      try {\r\n        currentToken = JSON.parse(storedUserInfoFromStorage).token;\r\n      } catch (e) {\r\n        console.error(\"[AuthContext] refreshUserProfile: Error parsing stored token from localStorage\", e);\r\n      }\r\n    }\r\n\r\n    // Fallback to token from current state if not in localStorage (e.g., if localStorage was cleared but state not yet updated)\r\n    if (!currentToken && userInfo && userInfo.token) {\r\n        console.log(\"[AuthContext] refreshUserProfile: Using token from current userInfo state as fallback.\");\r\n        currentToken = userInfo.token;\r\n    }\r\n\r\n    if (!currentToken) {\r\n      console.warn(\"[AuthContext] refreshUserProfile: No token available (checked localStorage and current state).\");\r\n      // setError(\"Unable to refresh profile: Not authenticated.\"); // Optionally set an error\r\n      return; // Cannot refresh without a token\r\n    }\r\n\r\n    try {\r\n      // setLoading(true); // Optional: manage loading state during refresh\r\n      console.log(\"[AuthContext] refreshUserProfile: Calling fetchUserProfileAPI (backend /auth/me)...\");\r\n      const response = await fetchUserProfileAPI(); \r\n      console.log(\"[AuthContext] refreshUserProfile: Data received from fetchUserProfileAPI (/auth/me):\", response.data);\r\n\r\n      // Ensure token is preserved. Prioritize new token from response, then existing context token, then currentToken from storage.\r\n      const freshUserInfo = {\r\n        ...response.data,\r\n        token: response.data.token || currentToken // Use currentToken as it's the one validated for this call\r\n      };\r\n      console.log(\"[AuthContext] refreshUserProfile: Preparing to set new userInfo:\", freshUserInfo);\r\n\r\n      setUserInfo(freshUserInfo);\r\n      localStorage.setItem('userInfo', JSON.stringify(freshUserInfo));\r\n      console.log(\"[AuthContext] refreshUserProfile: User profile refreshed. New streak should be:\", freshUserInfo.currentStreak);\r\n      setError(null); // Clear previous auth errors on successful refresh\r\n    } catch (err) {\r\n      console.error(\"[AuthContext] refreshUserProfile: Failed.\", err.response?.data?.message || err.message, err);\r\n      setError(err.response?.data?.message || \"Failed to refresh profile. Please try logging in again.\");\r\n      // Potentially logout user if refresh fails due to critical auth issues (e.g., token definitively invalid)\r\n      if (err.response?.status === 401 || err.response?.status === 403) {\r\n        console.log(\"[AuthContext] refreshUserProfile: Auth error during refresh, logging out.\");\r\n        logout(); // Call logout if token is rejected\r\n      }\r\n    } finally {\r\n      // setLoading(false); // Reset loading state if you used it\r\n    }\r\n  };\r\n\r\n  const login = async (credentials) => {\r\n    console.log(\"[AuthContext] Attempting login...\");\r\n    try {\r\n      setError(null);\r\n      const { data } = await loginAPI(credentials);\r\n      console.log(\"[AuthContext] Login successful, user data received:\", data);\r\n      setUserInfo(data); \r\n      localStorage.setItem('userInfo', JSON.stringify(data));\r\n      return data;\r\n    } catch (err) {\r\n      const errorMessage = err.response?.data?.message || err.message || 'Login failed';\r\n      console.error(\"[AuthContext] Login error:\", errorMessage, err);\r\n      setError(errorMessage);\r\n      throw new Error(errorMessage);\r\n    }\r\n  };\r\n\r\n  const register = async (userData) => {\r\n    console.log(\"[AuthContext] Attempting registration...\");\r\n    try {\r\n      setError(null);\r\n      const { data } = await registerAPI(userData);\r\n      console.log(\"[AuthContext] Registration successful, user data received:\", data);\r\n      // Assuming backend returns user object + token upon successful registration and auto-logins:\r\n      setUserInfo(data);\r\n      localStorage.setItem('userInfo', JSON.stringify(data));\r\n      return data;\r\n    } catch (err) {\r\n      const errorMessage = err.response?.data?.message || err.message || 'Registration failed';\r\n      console.error(\"[AuthContext] Registration error:\", errorMessage, err);\r\n      setError(errorMessage);\r\n      throw new Error(errorMessage);\r\n    }\r\n  };\r\n\r\n  const logout = () => {\r\n    console.log(\"[AuthContext] User logging out.\");\r\n    setUserInfo(null);\r\n    localStorage.removeItem('userInfo');\r\n    setError(null); // Clear any errors on logout\r\n    // Navigation should be handled by components observing userInfo\r\n  };\r\n  \r\n  // Function to manually set error from other parts of the app if needed\r\n  const setGlobalAuthError = (errorMessage) => {\r\n    setError(errorMessage);\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={{ \r\n        userInfo, \r\n        loading, \r\n        error, \r\n        login, \r\n        register, \r\n        logout, \r\n        setError: setGlobalAuthError, \r\n        refreshUserProfile \r\n    }}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}